# source: https://confluence.senlainc.com/pages/viewpage.action?pageId=89916302

# Название GitHub Action
name: Validate Pull request on Dev branch
 
# Триггеры, когда должен запускаться Action
on:
  # Action будет запускаться на Pull Request, также может запускать push, fork и другие ивенты
  pull_request:
    # Action будет срабатывать, когда PR открывается или новый коммит был запушен в remote ветку
    types: [opened, synchronize]
    # Фильтр на ветке, позволяет указать, что Action будет выполнен, если PR будет сливаться с "dev" веткой
    # 'releases/**' фильтр, будет срабатывать на все ветки, которые подпадают под паттерн
    branches: [ dev ]
    # Нам необходимо, чтобы Action срабатывал только на изменения по определенному пути
    paths:
      - 'force-app/**'
 
# Джобы, которые будут выполняться при соблюдении вышеуказанных условий
jobs:
  # Название джобы
  validate-deployment-on-develop-org:
    # Мы тут может указать, на какой ОС должна работать эта виртуальная машина.
    # В этом случае мы собираемся запускать наши команды в последней версии Ubuntu.
    runs-on: ubuntu-latest
    if: ${{ github.actor != 'dependabot[bot]' }}
    steps:
      # Устанавливаем nodejs в виртуальную машину и указываем версию 14.
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
 
      # Виртуальная машина может получить доступ к удаленному репозиторию, т.к. репозиторий является проектом sfdx.
      # Это действие по умолчанию, которое позволяет нам войти в корневой каталог репозитория.
 
      # Необходимо поставить fetch-depth:0 при checkout ветки. Это позволит получить доступ к коммитам, которые были отправлены ранее
 
      - name: 'Checkout source code'
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
 
      # Мы можем прочитать тело пул реквеста, например в нем можно указать тесты, которые нужно запустить при валидации
 
      - name: 'Read PR Body'
        # env: задает переменную, обращение к этой переменной происходит через следующий паттерн $переменная
        env:
        # Body PR может положить в переменную для ее дальнейшего использования
          PR_BODY: ${{github.event.pull_request.body}}
 
        # run:| содержит команды, которые запускаются в степе
        # PR_BODY можно положить в файл, сам файл может быть использован в сторонних скриптах, которые будут парсить текст
        # Так как разворачивается VM мы можем запускать любые скрипты (Python, JS и т.д.), которые лежат в репозитории
 
        run: |
          echo $PR_BODY > ./pr_body.txt
          node ./parsePR.js             
          TESTS=$(cat testsToRun.txt)      
          echo "APEX_TESTS=$TESTS" >> $GITHUB_ENV
 
      # Устанавливаем SFDX для деплоя и авторизации
      - name: 'Install Salesforce CLI'
        run: |
          wget https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-x64.tar.xz
          mkdir ~/sfdx
          tar xJf sfdx-linux-x64.tar.xz -C ~/sfdx --strip-components 1
          echo "$HOME/sfdx/bin" >> $GITHUB_PATH
          ~/sfdx/bin/sfdx version
 
      # Затем устанавливаем SFDX-Git-Delta - это плагин, которые создает package.xml с изменёнными метаданными
      # которые изменились после коммитов в PR
 
      - name: 'Installing sfdx git delta'
        run: |
          echo y | sfdx plugins:install sfdx-git-delta
          sfdx plugins
 
      # Устанавливаем JAVA для sf cli
      - name: 'Installing java'
        run: |
          sudo apt update
          sudo apt-get install openjdk-8-jdk-headless -qq > /dev/null
 
      # Интеграционный URL сохраним в файл для использования при авторизации
      - name: 'Populate auth file with SFDX_URL secret of integration org'
        shell: bash
        run: |
          echo ${{ secrets.SFDX_INTEGRATION_URL}} > ./SFDX_INTEGRATION_URL.txt
 
      # Авторизуемся в SF, в качестве примере авторизуемся через SFDX Auth Url
      - name: 'Authenticate to Integration Org'
        run: sfdx auth:sfdxurl:store -f ./SFDX_INTEGRATION_URL.txt -s -a integration
 
      # С помощью sfdx git delta создаем временным пакет с измеными метаданными, кроме package.xml, создается destructive changes,
      # которые позже можно так же запустить для удаления метададнных
      - name: 'Create delta packages for new, modified or deleted metadata'
        run: |
          mkdir changed-sources
          sfdx sgd:source:delta --to "HEAD" --from "HEAD^" --output changed-sources/ --generate-delta --source force-app/
 
      # if: контролирует, следует ли выполнять степ.
      # ${{env}} переменная содержит все переменные, которые были созданы во время выполнения скрипта
      - name: 'Check-only deploy delta changes - run specified tests'
        if: ${{ env.APEX_TESTS != 'all' }}
        run: |
          echo ${{env.APEX_TESTS}}
          sfdx force:source:deploy -p "changed-sources/force-app" --checkonly --testlevel RunSpecifiedTests --runtests ${{env.APEX_TESTS}} --json
 
      - name: 'Check-only deploy delta changes - run all tests'
        if: ${{ env.APEX_TESTS == 'all' }}
        run: |
          sfdx force:source:deploy -p "changed-sources/force-app" --checkonly --testlevel RunLocalTests  --json
 
      - name: 'Deploy destructive changes (if any)'
        run: sfdx force:mdapi:deploy -d "changed-sources/destructiveChanges" --checkonly --ignorewarnings